# spread-macros

[![spread-macros
crate](https://img.shields.io/crates/v/spread-macros.svg)](https://crates.io/crates/spread-macros)
[![spread-macros documentation](https://docs.rs/spread-macros/badge.svg)](https://docs.rs/spread-macros)

Macros around an extended spread syntax.

## `spread!`

An extension of the spread/struct update syntax that allow taking fields from different type
structs, as long as the listed fields have the same type in both structs. It supports modifier
prefixes allowing to perform common transformations, such as cloning, converting or taking a
reference.

## `anon!`

Generate a value of an anonymous struct with provided fields whose types are inferred. Can be used
to bundle many variables in a single struct to then be used in `spread!`. It supports the same
features as `spread!` (lists and modifiers) except for the final struct update syntax.

## `slet!`

Avoids having to write a lot of transforations like `let variable_with_long_name =
variable_with_long_name.clone()` (which is common with closures and async blocks) by listing all the
identifiers and transformations with the same syntax as `anon!`. In additation, each field name can
be prefixed by `mut` (before a potential modifier) to make a `let mut` binding.

## `fn_struct!`

Generates a struct representing the arguments of a given function or method, allowing to use Rust's
struct update syntax, `spread!` and `Default` with function arguments. The fields listed can use
modifiers from `spread!` like `&`, which allows for exemple to call functions with reference
arguments using a struct without references, which can thus implement `Default`. The struct can be
generic over the types of the function arguments, while the `call` function can also be generic over
types not appearing in the arguments.

It is targeted to be used when writing tests in which a function with many parameters is called
often and for which repeated arguments can be applied using `spread!`.

Asserts that some fields of the provided value match the expectation.

## `assert_fields_eq!`

This expectation can be expressed in 2 ways:
- Another value can be provided, followed by a list of fields both values have in common and should
  be equal.
- An anonymous struct with the same syntax as `anon!`.

Afterward, the macro accepts a custom panic message with formating like `assert_eq!`.

It uses the in-scope `assert_eq!` macro, which allows to use alternative macros like
`similar_asserts::assert_eq!` if wanted.

## Features

- `serde_derive`: structs generated by `anon!` will implement `Serialize`